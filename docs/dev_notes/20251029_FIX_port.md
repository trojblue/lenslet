the “single-port” behavior isn’t a backend port setting—it’s decided in the **frontend** by how the API base URL is computed.

# Where it is

- **Frontend › `api/client.ts`**

  ```ts
  const envBase = (import.meta as any).env?.VITE_API_BASE as string | undefined
  const isLocalHost = typeof window !== 'undefined' && /^(localhost|127\.0\.0\.1|\[::1\])$/i.test(window.location.hostname)
  const envPointsToLocal = !!envBase && /localhost|127\.0\.0\.1|\[::1\]/i.test(envBase)
  const BASE = !isLocalHost && envPointsToLocal ? '' : (envBase ?? '')
  ```

  When `BASE === ''`, all requests are **relative** (same scheme/host/port as the page), i.e., true single-port.

- **Frontend › `api/search.ts`** duplicates the same logic for its own `BASE`.

- **Backend:** there’s no port config. Single-port serving happens because `main.py` mounts the built frontend at `/`:

  ```py
  if settings.frontend_dist and os.path.isdir(settings.frontend_dist):
      app.mount("/", StaticFiles(directory=settings.frontend_dist, html=True), name="frontend")
  ```

  The port is whatever you run the server on (e.g., uvicorn), and the frontend uses it when `BASE === ''`.

# Is the config being read?

Yes—`import.meta.env.VITE_API_BASE` is read **at build time** by Vite. The runtime host decision uses `window.location.hostname`. So the behavior depends on both:

- **Dev:** page on `localhost` ⇒ honor `VITE_API_BASE` (e.g., `http://localhost:8000`).
- **Prod/tunnel:** page *not* on `localhost` and `VITE_API_BASE` points to localhost ⇒ ignore it and use relative `''` (same origin/port).

# Why it “sometimes regresses”

Two fragilities:

1. **Duplicated logic** (`client.ts` and `search.ts`). If one file changes and the other doesn’t, parts of the app talk to different origins/ports.
2. **Narrow host checks.** The regex only matches exactly `localhost`, `127.0.0.1`, or `[::1]`. Cases like `foo.localhost`, `0.0.0.0`, or custom dev hostnames (`lenscat.local`) aren’t treated as local. A small change to environment or how you access the site can flip the branch and send requests to the wrong origin/port.

(Also: if `VITE_API_BASE` is set to `http://…` while the site is `https://…`, the browser will block mixed content. That can look like a “wrong port” failure.)

# Concrete fix (robust + removes duplication)

Unify the base-URL computation and broaden “local” detection. Example:

**`frontend/api/base.ts`** (new)

```ts
// Single source of truth for API base URL
export function computeApiBase(): string {
  const envBase = (import.meta as any).env?.VITE_API_BASE as string | undefined
  const inBrowser = typeof window !== 'undefined'
  const pageOrigin = inBrowser ? window.location.origin : 'http://localhost'
  const pageHost = inBrowser ? window.location.hostname : 'localhost'

  const isLocalHostName = /^(localhost|127\.0\.0\.1|0\.0\.0\.0|\[::1\]|.+\.localhost)$/i.test(pageHost)

  if (!envBase) return '' // default to same-origin (single-port)

  // Normalize envBase against page origin if it's a relative path
  let envUrl: URL
  try { envUrl = new URL(envBase, pageOrigin) } catch { return '' }

  const envIsLocal = /^(localhost|127\.0\.0\.1|0\.0\.0\.0|\[::1\])$/i.test(envUrl.hostname)

  // In local dev, allow explicit override (e.g., Vite on 5173 -> API on 8000)
  if (isLocalHostName) return envUrl.origin

  // In production/tunnel, ignore localhost overrides to keep same-origin
  if (envIsLocal) return ''

  // Otherwise honor explicit non-local origin (e.g., separate API domain)
  return envUrl.origin
}

export const BASE = computeApiBase()
```

**Change both `api/client.ts` and `api/search.ts` to import it:**

```ts
import { BASE } from './base'  // or '../api/base'
```

…and remove their local `BASE` blocks.

This gives you:

- One place to reason about behavior.
- Safer local-host detection (handles `*.localhost`, `0.0.0.0`).
- Default single-port in prod unless you *explicitly* point at another non-local API.

# Optional safety net (non-breaking)

Add a quick runtime check once on app start to warn (in dev) if the chosen origin doesn’t respond:

```ts
// somewhere early (e.g., App.tsx bootstrap), not blocking UI
import { BASE } from './api/base'
fetch(`${BASE}/health`).catch(() => {
  if (import.meta.env?.DEV) {
    console.warn(`[lenscat] API not reachable at ${BASE || 'same-origin'}. Falling back to same-origin.`)
  }
})
```

# Operational notes

- In **prod builds**, prefer leaving `VITE_API_BASE` **unset** so the default is single-origin/port.
- If you must point to a separate API in prod, set `VITE_API_BASE` to a full **https** origin for that API.

