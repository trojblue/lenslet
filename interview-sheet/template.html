<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interview Sheet</title>
  <style>
    :root {
      color-scheme: light;
      --bg-1: #f6f2ea;
      --bg-2: #e8eef8;
      --card: #ffffff;
      --ink: #1b1f2a;
      --muted: #5e6777;
      --accent: #1f6feb;
      --accent-soft: rgba(31, 111, 235, 0.12);
      --border: rgba(27, 31, 42, 0.12);
      --danger: #b3261e;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      color: var(--ink);
      background: radial-gradient(circle at top left, var(--bg-2), transparent 55%),
                  radial-gradient(circle at 85% 20%, #f0e2d0, transparent 50%),
                  linear-gradient(140deg, var(--bg-1), #fdfdfc 55%, #f1f5fb);
    }

    .wrap {
      max-width: 820px;
      margin: 4vh auto;
      padding: 0 20px 40px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
      margin-bottom: 14px;
    }

    .title {
      font-size: 28px;
      font-weight: 700;
      letter-spacing: -0.02em;
    }

    .count {
      font-size: 13px;
      color: var(--muted);
      background: rgba(0,0,0,0.04);
      padding: 6px 10px;
      border-radius: 999px;
    }

    .desc {
      font-size: 15px;
      color: var(--muted);
      margin-bottom: 20px;
    }

    .card {
      background: var(--card);
      border-radius: 18px;
      padding: 24px;
      box-shadow: 0 20px 45px rgba(27, 31, 42, 0.12);
      border: 1px solid var(--border);
    }

    .question {
      padding: 18px 0;
      border-bottom: 1px solid var(--border);
    }

    .question:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .q-label {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 10px;
      display: flex;
      align-items: baseline;
      gap: 10px;
    }

    .q-label .required {
      font-size: 12px;
      color: var(--danger);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .q-prompt {
      font-size: 15px;
      color: var(--ink);
      line-height: 1.5;
      margin-bottom: 16px;
    }

    .q-prompt p {
      margin: 0 0 10px;
    }

    .q-prompt ul,
    .q-prompt ol {
      margin: 0 0 10px 18px;
      padding: 0;
    }

    .q-prompt code {
      background: #f4f4f4;
      padding: 2px 4px;
      border-radius: 4px;
      font-family: "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: 0.95em;
    }

    .q-prompt pre {
      background: #f4f4f4;
      padding: 12px;
      border-radius: 8px;
      overflow-x: auto;
      font-family: "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: 0.92em;
    }

    .q-prompt mark {
      background: #fff2a8;
      padding: 0 4px;
      border-radius: 4px;
    }

    .options {
      display: grid;
      gap: 10px;
      margin-bottom: 12px;
    }

    .option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fbfbfd;
      transition: border 0.15s ease, background 0.15s ease;
    }

    .option input {
      accent-color: var(--accent);
      width: 18px;
      height: 18px;
    }

    .option:hover {
      border-color: rgba(31, 111, 235, 0.4);
      background: #f5f8ff;
    }

    .option.none {
      border-style: dashed;
    }

    .textarea {
      width: 100%;
      min-height: 120px;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
      font-family: inherit;
    }

    .textarea:focus {
      outline: 2px solid var(--accent-soft);
      border-color: rgba(31, 111, 235, 0.6);
    }

    .label-sm {
      font-size: 13px;
      color: var(--muted);
      margin: 6px 0 8px;
    }

    .error {
      color: var(--danger);
      font-size: 13px;
      margin-top: 10px;
      min-height: 18px;
    }

    .actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 20px;
    }

    .btn {
      padding: 10px 18px;
      border-radius: 10px;
      font-weight: 600;
      border: 1px solid var(--border);
      background: #ffffff;
      color: var(--ink);
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }

    .btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
      box-shadow: 0 12px 20px rgba(31, 111, 235, 0.18);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
    }

    .submitted {
      text-align: center;
      padding: 40px 20px;
    }

    .submitted h2 {
      margin: 0 0 12px;
    }

    @media (max-width: 640px) {
      .wrap { margin: 2vh auto; }
      .title { font-size: 22px; }
      .card { padding: 18px; }
      .actions { justify-content: stretch; }
      .btn { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="title" id="title"></div>
      <div class="count" id="count"></div>
    </div>
    <div class="desc" id="desc"></div>
    <div class="card" id="card">
      <form id="form">
        <div id="questions"></div>
        <div class="actions">
          <button class="btn primary" id="submit" type="submit">Submit</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    const QUESTIONS = __QUESTIONS__;

    function escapeHtml(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function renderMarkdown(text) {
      if (!text) return "";
      let escaped = escapeHtml(text);
      const blocks = [];
      escaped = escaped.replace(/```([\s\S]*?)```/g, (_, code) => {
        const idx = blocks.length;
        blocks.push(`<pre><code>${code.trim()}</code></pre>`);
        return `@@CODEBLOCK${idx}@@`;
      });
      escaped = escaped.replace(/`([^`]+)`/g, '<code>$1</code>');
      escaped = escaped.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      escaped = escaped.replace(/==([^=]+)==/g, '<mark>$1</mark>');

      const lines = escaped.split(/\n/);
      let html = "";
      let inUl = false;
      let inOl = false;
      for (const rawLine of lines) {
        const line = rawLine.trimEnd();
        if (line.trim() === "") {
          if (inUl) { html += "</ul>"; inUl = false; }
          if (inOl) { html += "</ol>"; inOl = false; }
          continue;
        }
        const codeMatch = line.match(/^@@CODEBLOCK(\d+)@@$/);
        if (codeMatch) {
          if (inUl) { html += "</ul>"; inUl = false; }
          if (inOl) { html += "</ol>"; inOl = false; }
          html += blocks[Number(codeMatch[1])] || "";
          continue;
        }
        const ulMatch = line.match(/^[-*]\s+(.*)$/);
        if (ulMatch) {
          if (inOl) { html += "</ol>"; inOl = false; }
          if (!inUl) { html += "<ul>"; inUl = true; }
          html += `<li>${ulMatch[1]}</li>`;
          continue;
        }
        const olMatch = line.match(/^(\d+)\.\s+(.*)$/);
        if (olMatch) {
          if (inUl) { html += "</ul>"; inUl = false; }
          if (!inOl) { html += "<ol>"; inOl = true; }
          html += `<li>${olMatch[2]}</li>`;
          continue;
        }
        if (inUl) { html += "</ul>"; inUl = false; }
        if (inOl) { html += "</ol>"; inOl = false; }
        html += `<p>${line}</p>`;
      }
      if (inUl) html += "</ul>";
      if (inOl) html += "</ol>";
      return html;
    }

    const steps = [...(QUESTIONS.questions || [])];
    if (!QUESTIONS.final_note || QUESTIONS.final_note.enabled !== false) {
      steps.push({
        id: "__final_note__",
        type: "final",
        label: (QUESTIONS.final_note && QUESTIONS.final_note.label) || "Anything else to add?",
        prompt: (QUESTIONS.final_note && QUESTIONS.final_note.prompt) || "Optional extra context or follow-ups.",
        required: false,
      });
    }

    const titleEl = document.getElementById("title");
    const descEl = document.getElementById("desc");
    const countEl = document.getElementById("count");
    const questionsEl = document.getElementById("questions");
    const formEl = document.getElementById("form");
    const cardEl = document.getElementById("card");

    titleEl.textContent = QUESTIONS.title || "Interview Sheet";
    descEl.innerHTML = renderMarkdown(QUESTIONS.description || "");
    countEl.textContent = `${steps.length} question${steps.length === 1 ? "" : "s"}`;

    function buildTextArea(labelText, placeholder, dataAttr) {
      const label = document.createElement("div");
      label.className = "label-sm";
      label.textContent = labelText;
      const textarea = document.createElement("textarea");
      textarea.className = "textarea";
      textarea.placeholder = placeholder;
      if (dataAttr) textarea.dataset[dataAttr] = "true";
      return { label, textarea };
    }

    function renderQuestions() {
      steps.forEach((step, idx) => {
        const block = document.createElement("section");
        block.className = "question";
        block.dataset.qid = step.id;

        const labelWrap = document.createElement("div");
        labelWrap.className = "q-label";
        const labelText = document.createElement("span");
        labelText.textContent = step.label || `Question ${idx + 1}`;
        labelWrap.appendChild(labelText);
        if (step.required) {
          const req = document.createElement("span");
          req.className = "required";
          req.textContent = "Required";
          labelWrap.appendChild(req);
        }

        const prompt = document.createElement("div");
        prompt.className = "q-prompt";
        prompt.innerHTML = renderMarkdown(step.prompt || "");

        block.appendChild(labelWrap);
        block.appendChild(prompt);

        if (step.type === "choice") {
          const optionsWrap = document.createElement("div");
          optionsWrap.className = "options";
          const optionInputs = [];

          (step.options || []).forEach((opt, optIndex) => {
            const row = document.createElement("label");
            row.className = "option";
            const input = document.createElement("input");
            input.type = "checkbox";
            input.dataset.option = opt;
            input.id = `${step.id}-opt-${optIndex}`;
            const span = document.createElement("span");
            span.textContent = opt;
            row.appendChild(input);
            row.appendChild(span);
            optionsWrap.appendChild(row);
            optionInputs.push(input);
          });

          let noneInput = null;
          if (step.allow_none) {
            const row = document.createElement("label");
            row.className = "option none";
            noneInput = document.createElement("input");
            noneInput.type = "checkbox";
            noneInput.dataset.none = "true";
            const span = document.createElement("span");
            span.textContent = step.none_label || "None of the choices";
            row.appendChild(noneInput);
            row.appendChild(span);
            optionsWrap.appendChild(row);
          }

          block.appendChild(optionsWrap);

          if (step.allow_text) {
            const textLabel = step.text_label || "Elaboration (optional)";
            const textPlaceholder = step.text_placeholder || "Add detail if helpful.";
            const { label, textarea } = buildTextArea(textLabel, textPlaceholder, "elaboration");
            block.appendChild(label);
            block.appendChild(textarea);
          }

          if (noneInput) {
            const syncNoneState = () => {
              if (noneInput.checked) {
                optionInputs.forEach((input) => {
                  input.checked = false;
                  input.disabled = true;
                });
              } else {
                optionInputs.forEach((input) => {
                  input.disabled = false;
                });
              }
            };

            noneInput.addEventListener("change", syncNoneState);
            optionInputs.forEach((input) => {
              input.addEventListener("change", () => {
                if (input.checked && noneInput.checked) {
                  noneInput.checked = false;
                  syncNoneState();
                }
              });
            });
          }
        } else {
          const textLabel = step.text_label || (step.type === "final" ? "Notes (optional)" : "Response");
          const textPlaceholder = step.text_placeholder || "Type your answer here.";
          const { label, textarea } = buildTextArea(textLabel, textPlaceholder, "text");
          block.appendChild(label);
          block.appendChild(textarea);
        }

        const error = document.createElement("div");
        error.className = "error";
        block.appendChild(error);

        questionsEl.appendChild(block);
      });
    }

    function setError(block, message) {
      const errorEl = block.querySelector(".error");
      if (errorEl) errorEl.textContent = message || "";
    }

    function collectAnswers() {
      const answers = {};
      let firstError = null;

      steps.forEach((step) => {
        const block = questionsEl.querySelector(`[data-qid="${step.id}"]`);
        if (!block) return;
        setError(block, "");

        if (step.type === "choice") {
          const optionInputs = Array.from(block.querySelectorAll('input[type="checkbox"][data-option]'));
          const noneInput = block.querySelector('input[type="checkbox"][data-none]');
          const selected = optionInputs.filter(i => i.checked).map(i => i.dataset.option);
          const noneSelected = noneInput ? noneInput.checked : false;
          let error = "";

          if (noneSelected && selected.length > 0) {
            error = "Choose either a selection or none of the choices.";
          } else if (step.required && !noneSelected && selected.length === 0) {
            error = "Please pick at least one option.";
          } else if (!noneSelected && step.min && selected.length < step.min) {
            error = `Please select at least ${step.min} option(s).`;
          } else if (!noneSelected && step.max && selected.length > step.max) {
            error = `Please select no more than ${step.max} option(s).`;
          }

          if (error) {
            setError(block, error);
            if (!firstError) firstError = block;
          }

          const textArea = block.querySelector('textarea[data-elaboration="true"]');
          const text = textArea ? textArea.value.trim() : "";
          answers[step.id] = {
            type: step.type,
            selected,
            none_selected: noneSelected,
            text,
          };
        } else {
          const textArea = block.querySelector("textarea");
          const text = textArea ? textArea.value.trim() : "";
          if (step.required && !text) {
            setError(block, "Please add a response.");
            if (!firstError) firstError = block;
          }
          answers[step.id] = {
            type: step.type,
            text,
          };
        }
      });

      if (firstError) {
        firstError.scrollIntoView({ behavior: "smooth", block: "center" });
        return null;
      }
      return answers;
    }

    function showSubmitted() {
      cardEl.innerHTML = '<div class="submitted"><h2>Thanks! Saved locally.</h2><p>You can close this tab now.</p></div>';
    }

    async function submitAnswers() {
      const answers = collectAnswers();
      if (!answers) return;
      const payload = { answers, version: 1 };
      try {
        const resp = await fetch("/submit", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!resp.ok) throw new Error("Server error");
        showSubmitted();
      } catch (err) {
        const fallback = document.createElement("div");
        fallback.className = "error";
        fallback.textContent = "Submit failed. Please try again.";
        questionsEl.appendChild(fallback);
      }
    }

    formEl.addEventListener("submit", (event) => {
      event.preventDefault();
      submitAnswers();
    });

    renderQuestions();
  </script>
</body>
</html>
